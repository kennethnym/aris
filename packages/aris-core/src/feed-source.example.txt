/**
 * Example wiring of FeedSource graph.
 * NOT for documentation - just to visualize the interface.
 */

import type { Context, ContextKey, FeedItem, FeedSource } from "./index"
import { contextKey, contextValue } from "./index"

// ============================================================================
// Context Keys - exported by each package
// ============================================================================

interface Location {
	lat: number
	lng: number
}

interface Weather {
	temperature: number
	condition: string
}

const LocationKey: ContextKey<Location> = contextKey("location")
const WeatherKey: ContextKey<Weather> = contextKey("weather")

// ============================================================================
// Feed Items
// ============================================================================

interface WeatherFeedItem extends FeedItem<"weather", { temperature: number; condition: string }> {}

// ============================================================================
// Sources
// ============================================================================

// Location source - context only, no feed items
const locationSource: FeedSource = {
	id: "location",

	onContextUpdate(callback, _getContext) {
		// Reactive: browser pushes location changes
		const watchId = navigator.geolocation.watchPosition((pos) => {
			callback({
				[LocationKey]: {
					lat: pos.coords.latitude,
					lng: pos.coords.longitude,
				},
			})
		})
		return () => navigator.geolocation.clearWatch(watchId)
	},

	async fetchContext(_context) {
		// On-demand: manual refresh
		const pos = await new Promise<GeolocationPosition>((resolve, reject) => {
			navigator.geolocation.getCurrentPosition(resolve, reject)
		})
		return {
			[LocationKey]: {
				lat: pos.coords.latitude,
				lng: pos.coords.longitude,
			},
		}
	},
}

// Weather source - depends on location, provides context + feed items
const weatherSource: FeedSource<WeatherFeedItem> = {
	id: "weather",
	dependencies: ["location"],

	async fetchContext(context) {
		const location = contextValue(context, LocationKey)
		if (!location) return {}

		// Fetch weather from API
		const weather = await fetchWeatherFromApi(location)
		return { [WeatherKey]: weather }
	},

	async fetchItems(context) {
		const weather = contextValue(context, WeatherKey)
		if (!weather) return []

		return [
			{
				id: `weather-${Date.now()}`,
				type: "weather",
				priority: 0.5,
				timestamp: new Date(),
				data: {
					temperature: weather.temperature,
					condition: weather.condition,
				},
			},
		]
	},
}

// ============================================================================
// Graph wiring (conceptual - FeedSourceGraph not yet implemented)
// ============================================================================

// const graph = new FeedSourceGraph([
//   locationSource,
//   weatherSource,
// ])
//
// // Graph validates:
// // - All dependencies exist
// // - No circular dependencies
// // - Topologically sorts sources
//
// // On refresh:
// // 1. fetchContext on location (no deps)
// // 2. fetchContext on weather (has location in context now)
// // 3. fetchItems on all sources
// // 4. Return combined feed items
//
// // On reactive update from location:
// // 1. Update context with new location
// // 2. Trigger weather.fetchContext (it depends on location)
// // 3. Trigger weather.fetchItems
// // 4. Notify subscribers

// ============================================================================
// Helpers (mock)
// ============================================================================

async function fetchWeatherFromApi(_location: Location): Promise<Weather> {
	return { temperature: 20, condition: "sunny" }
}

export { locationSource, weatherSource }
